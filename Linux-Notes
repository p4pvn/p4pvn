Linux File System:
Root directory (/): This is the top-level directory in the file system hierarchy. All other directories and files are organized under the root directory.
/bin directory: Contains essential binary executable files used by all users.
/etc directory: Holds system-wide configuration files.
/home directory: Home directories for regular users.
/usr directory: Contains user-readable data, applications, and libraries.
/var directory: Holds variable data like logs, databases, and temporary files.

Reboot command:
reboot
systemct reboot
shutdown -r 5:30 (schedule reboot ,24hr clock type)
shutdown -r +15 (schedule reboot after 15 min)
shutdown -c (cancel shutdown)
shutdown -r now (reboot right now)

shutdown commands:
systemctl poweroff
poweroff

Run levels: These are numbered states that determine the system's operational mode and the services or processes that are running.

init 0 (shutdown)
init 1 (single-user mode or maintenance mode)
init 2 (Multi-User Mode without N/W)
init 3 (Multi-User Mode with Networking(allow multiple user login)) - default/standard - fully functional
init 4 (Unused or Custom Configurations)
init 5 (GUI)
init 6 (force reboot)

shutdown -h 5:30 (scheduled)
[ -h for shutdown and -r for reboot ]

5. FILE HIERARCHY:
Root directory - /
sub directory - root boot etc bin sbin dev tmp lib lib64 (total 19)
root ~/- home directory
boot - booting file store
etc - system confg file
bin - commands store
sbin - command store which is used by user
tmp - to store temporary data
dev - store external files like PD data
home - home directory for users
lib - store library for 32 bit
lib64 - store library 64 bits
opt - install 3d party software
proc - process information store
mnt - store mounting info
run - run media devices
usr - store user documentation (help,)

command syntax in linux:
command option argument

commands:
pwd -present working directory
cd -change directory 
cd /tmp -change dire. to tmp
cd /home/pawan -cd to home and pawan folder
cd -  -prev working directory
cd ../..  -2 step backword

6. LS COMMANDS: will show folder and files in directory
ls  -list for current location
ls /tmp  -list for tmp
ls /tmp

lsusb  -list of usb devices connected to system

7. Touch command for file creation
 touch /tmp/idn.txt would create file in tmp named idn.txt

man command for manual/guide to particular command:
man cat   -it will show you manual to cat command
cat --help   -it will help you with given command

ip address         - will show the IP Address.
curl ifconfig.me   -will show public IP

8.Mkdir for folder creation
  mkdir full form is make directory
mkdir /tmp/pawan{1..5}    -will create 5 folders in tmp.
mkdir "pawan pawan"   -if there is space, use ""
mkdir -p /parent/directory     -it will create parent directories if doesn't exist
mkdir -m 755 pawan        -it will set permission/mode as 755 to pawan.

mkdir -p -m 755 /path/to/new/dire     -it will create parent directory and set permission/mode as well.
rmdir (remove directory) used for remove/delete directory.

9. cat command to read file
cat pawan.txt    -will display the content of pawan.txt
cat pawan.txt pavan.txt    -will display content of pawan.txt and then pavan.txt
cat >pawan.txt      -will create pawan.txt and write in file then :wq! to save it
cat pawan.txt pavan.txt >combined.txt    -will combine content of pawan and pavan, and will save it to combined.txt
cat >>pawan.txt       -will add more data in pawan.txt
cat -n pawan.txt        -will show data in numberline.
tac for inverse data (line by line)
nl pawan.txt to read file

10. use ; for multiple commands at once
cd tmp ; mkdir pawan ; pwd

pipe command |
command 1 | command 2              -It serves output of command 1 to input for command 2.
grep "pawan" tmp.txt | wc -l       -It will search for "pawan" in tmp.txt and will give input to wc -l which will count and print no. of lines.

Redirection (> & >>) allow you to redirect the standard output (stdout) of a command to a file instead of displaying it on the terminal.
ls > file_list.txt     -file_list will be created and output of "ls" will be written in "file_list"
ls >> file_list.txt    -It will append/add output of "ls" in existing file "file_list"

Input Redirection (<):
This allows you to take input from a file instead of the keyboard.
Example: command < file.txt
mkdir < pawan.txt       #it will make file name based on content of pawan.txt

here documents(<<):  Provides a way to pass multiple lines of input to a command.
cat << EOF
Line 1
Line 2
EOF

/dev/null:  A special file that discards data written to it. Useful for suppressing output.
Example: command >/dev/null

redirect output and error to seperate files:
command >output.txt 2>error.txt    -if command gives op, it will be saved in output.txt, and if error then error.txt

Shell Expansion: (diff betn "" and '')
1. name="DevOps"
echo '$name'   # Outputs: $name (no expansion)
2. name="DevOps"
echo "Hello $name"   # Outputs: Hello DevOps

Command Substitution:
echo "Today is $(date)"     # → Today is Sun Sep 28 11:35:12 IST 2025
echo 'Today is $(date)'   # → Today is $(date)  (literal string, no expansion)

echo "Line1\nLine2"   # → Line1
                      #   Line2

echo "{\"env\": \"$name\"}"       # → {"env": "DevOps"}
if you add \ (backward slash) before " (double quotes), it will ignore the " (double quotes).

Useful when handling JSON, YAML, CI/CD configs, or Kubernetes manifests.

double quotes do shell expansion while single quotes doesnt do shell expansion and take values as literal. (avoid single quotes mostly)

wc command: word count
wc -l file.txt    -it will count number of lines in file.txt
wc -w file.txt    -it will count number of words in file.txt
wc -c file.txt    -it will count number of characters in file.txt

alias: you can create shortcuts for long commands.
alias pawan='cd /home/ec2-user/pawan'
unalias pawan  - remove alias

less: It shows you the content stored inside a file, in a nice and interactive UI.

sort: It sorts the content of the file (alphabetically).
sort -r :reverse sort from z to a

uniq: It removes duplicate content/words/lines.

diff: it will show you diff betn two files.

xargs:  It takes input from a pipe or from standard input and converts it into arguments for given command.
cat todelete.txt | xargs rm       (xargs rm < todelete.txt)

tr command stands for 'translate':
echo "pavan" | tr 'pavan' 'pawan'    -replaces pavan with pawan  #output: pawan
echo "Hello World" | tr -d 'l'       -deleting 'l' from stdint   #output: Heo Word
echo "hello" | tr -c 'a-z' 'A-Z'     -complementing small set by caps  #output: HELLO
echo "abcdef" | tr 'a-c' 'x-z'       -translate the range of set  #output: xyzdef
echo "aapple" | tr -s 'a'            -it will squeeze multiple 'a's to one #output: apple

11. head and tail command (To read command)
head for top to bottom 
tail for bottom to top
head -n 15 myfile.txt    -will show you 15 lines only from top
head -n -15 myfile.txt    - will show you all line except last 15.
tail -n 15 myfile.txt    -will show you 15 lines only from bottom
tail -n -15 myfile.txt    - will show you all line except first 15.
head -n 15 | tail -n 1    - will show you line no. 15 only

head -c 20             - will show you 1st 20 characters from file
tail -c 20             - will print last 20 characters from file

#show line number x to y:
sed -n 'x,yp' abc.txt
head -n y abc.txt | tail +x

12. echo command for message printing
echo "hello world of linux" will pass msg
echo "pawan" >pawan.txt -message will be saved in pawan.txt

13. rm command to remove/delete file
press Y to yes and N to no.
rm myfile.txt  -to delete file
rm -rf pawan   -to delete folder/directory.

rename command to rename the file/folder
mv oldname newname

14. copy file/folder to file/folder:
cp abc.txt pawan   #copy abc file to pawan folder
cp -rvf abc pawan  #copy abc folder to pawan folder

cp also means overwrite:
cp abc.txt xyz.txt        #it will completely remove the content of xyz and replace it w abc.

remote copying from server:
scp for secure copy
scp options user@host1:source_file_or_directory user@host2:destination
scp for file copying:
scp -i key.pem test.txt pawan@10.143.90.2:/home/pawan

rsync for directory copying / syncing
rsync -avz /path/to/local/directory root@IP:/path/to/destination/directory       (if vpc peering is done, then privateIP if not then publicIP)
-a : archive mode (preserve metadata of file like owner permission links)
-v : verbose
-z : zip compress data during transfer
--delete: by default, rsync only updates or adds, never removes, with --delete, it removes as well.

Checksums:
A checksum is an integrity check used by systems during data transfer to verify the integrity of data (between the source and destination).
checksum is a unique digital fingerprint (hash) that represents the content of a file or data stream.

if hash/checksum matches between source and destination, then integrity not compromised, you can proceed safely ahead.
if not, then data is corrupted, manipulate, cannot proceed with data.

Original file (text.log)     → checksum: A1B2C3
After network copy           → checksum: A1B2C3  ✅ same
After data corruption        → checksum: 9F8E7D  ❌ different


checksum is used by rsync, git, docker image, s3, terraform, linux packages, iso (disc image file).

checksum/hashing algorithms:                                   OUTPUT characters
MD5 - common checks- basic                                      32 characters
SHA-1 - used in legacy systems - faked easily                   40 characters
SHA-256 - stronger integrity check - slower speed               64 characters
SHA-512/BLAKE2 - cryptography                                   128+ characters


copying file from AWS to Local:
scp -i "C:\Users\PAWAN\Downloads\name2.pem" ubuntu@54.88.229.129:/etc/nginx/nginx.conf "C:\Users\PAWAN\OneDrive\Desktop\nginx.conf"

ln:
It's used to create links. What is a link? It's like a
pointer to another file. A file that points to another file.
2 types of links: HardLinks and Softlinks

1.hardlinks: (it points to hardware data)
you can't link to directories, and you can't link to external filesystems (disks).
Any time you edit any of those files, the content will be updated for both.
> ln recipes.txt newrecipes.txt
If you delete the original file, the link will still contain the original file content
A hard link always points a filename to data on a storage device.

2.softlinks: (it's like shortcuts to original file like windows)
They are more powerful as you can link to other filesystems and to directories.
if original is removed, the link will be broken
> ln -s recipes.txt newrecipes.txt
if you delete the original file, the links will be broken

tee command:
tee command is used to read from standard input and write to both standard output and one or more files simultaneously.
It is a handy utility for redirecting output to a file while still displaying it on the terminal.

echo "Data" | tee file1.txt file2.txt
      -It will print the "Data" on terminal as well as save "Data" in given txt files(single or multiple).

echo "New content" | tee -a file_list.txt
    -you can append to existing file to avoid overwriting. it will add "New content" to file_list.txt

mail command:
echo "body" | mail -s "subject" "recipient"
echo "server off" | mail -s "Alert" "pawanugalmugale@gmail.com" 
      #It will send mail to "pawan" with subject as "alert" and content as "server off".

15. vim is an editor. insert and escape and command mode
escape mode is default while entering in a file.
vim /etc/passwd   -to enter file name passwd
press x           -single letter delete
4 press x         -4 letter delete
dw                -delete word
dd                -delete line
5 dd              -5 line delete
shift G           - bottom
gg                -top
u                 -undo
ctrl R            ss-redo
shift zz          -exit from vim
i                 -insert mode before cursor
esc               -exit from insert mode
a                 -insert mode after cursor
o                 -insert mode blank line below
shift o           -insert mode blank line above
shift :           -command mode
shift : !         -command mode like terminal
:wq!              -exit
:q!               -exit without saving

sed command in linux:
It is used for text manipulation and useful for performing search-and-replace operations, editing specific lines to text files or input streams
sed 's/apple/banana/' fruit.txt        -substitute apple with banana                   #it won't change content of file, it will just echo manipulation.
sed 'error/d' logfile.txt              -delete the word 'error' in logfile
sed -n '5,10p' documents.txt           -print 5 to 10 lines
sed -n '15p' docs.txt                  -print line number 15

#show line number x to y:
sed -n 'x,yp' abc.txt
head -n y abc.txt | tail +x

16. Grep command (used for searching lines)
grep options argument filename
grep -ino "pawan" tmp  -pawan in tmp file (i -ignore case, n  -line number and o -onlyword)
grep -in '^pawan' tmp   -lines where pawan is at start
grep -in 'pawan$' tmp   -line with pawan at the end.
grep -v "error" tmp   -lines where error word is not present.
grep -r "pattern" .   -it will search for word pattern recursively in pwd.
grep -A 4 "pawan" tmp      -pawan with next 4 lines After
grep -B 4 "pawan" tmp      -pawan with before 4 lines
grep -C 4 "pawan" tmp      -pawan with After & Before 4 lines
egrep -in "pawan|soni|vijaya" tmp  -enhanced grep for multiple search
grep -in 'Aug 24 08:51' tmp   -search for logs 24th Aug @ 8:51 AM (24hr)
grep -oP '.{4}pawan.{4}'    - it will print 4 words before and 4 words after argument.


Find command: used to search for files and directories within a specified path.
find [path] [expression]                    #command syntax
#find file with filename in specified path

find /path/to/search -iname "filename"      #find file with filename with ignoring case-sensitivity
find . -type f -name "*.txt"                #find all .txt file in current directory
find /path/to/search -size +1M              #find files with size more than 1MB
find /path/to/search -user username         #find files created by particular user
find /path/to/search -perm /o=r             #find files with given permission (read to others)
find /path/to/search -empty -delete         #find all empty files and delete it.


cut command: It is used to extract specific columns or fields from lines of text in a file.
cut -f 1,3 input.txt          #Extracts fields/columns 1 and 3 from input.txt
cut -f 2-4 input.txt          # Extracts fields/columns 2 to 4 from input.txt
cut -d ',' -f 1,3 input.csv   # Extracts fields/columns 1 and 3 from a CSV file using a comma as the delimiter/seperator.
cut -f 2 --complement -d ',' input.txt       #Display all fields/columns except 2nd field/column.
cut -c 3                     #extract 3rd character from word
cut -c 1-5                   #extract 1st to 5th character range from word
 
AWK Command: It is also used to extract specific column or field from txt file.
awk '{print $1, $3}' data.txt                -it will print column 1 and 3 from data.txt
awk -f ',' '{print $2, $4}' employee.csv     -print 2nd and 4th column seperated by comman in employee.csv
awk '{total = $2+$3+$4 ; print $1 , total}' grade.txt     -it will collect addition of 2,3,4 columns in total and print 1st column and total value.

cut has delimiter and fields (df).
awk has field seperator and '{print $1}'

17. Tar comment(for archieving and compressing)
3 methods in Tar command: gunzip, bunzip, xz
syntax: tar option archieve-foldername file&folder
archieve folder pawan:  tar -cf archievepawan pawan
extract folder archievepawan: tar -xf archievepawan pawan
compressed using gunzip method: tar -zcf redhat.tar.gz 
compressed using bunzip method: tar -Jcf redhat.tar.bz2
compressed using xz method: tar -Jcf redhat.tar.xz

ZIP file:  zip pawan.zip 

tar -cf archive.tar pawan    # Create archive.tar from files pawan
tar -xf archive.tar          # Extract all files from archive.tar

history: it will show you previously executed commands for current user.

you can turn history off temporarily:
set +o history
and turn back on:
set -o history

19. Process Management:

each process has  PID,        PPID,      State,   Owner,   Priority/Nice value,    Resources
                process ID, parent PID, running,  user,     number                 CPU, Memory
                                        sleep, stop, zombie, orphan
types of process:
foreground process: blocks the terminal like top, vi, watch
Background process: runs in background with detached terminal (with & in end) like sleep 60 &
Daemon process: long-running services like sshd, systemctl start/enable
Zombie process: task/process has completed but still showing entry in data table.
Orphan process: Parent process completed but child process still alive/running

"ps" stands for "process status." It helps users and system administrators to monitor and manage processes.
ps      -lists processes started by the current user
ps -e   -Shows information about all running processes
ps -f   -provides output in full format (process ownership, parent process ID, CPU, memory usage, start time)
ps -ef  -display information about all running processes in a detailed format
ps -u <username>     -proccess started by specific user
ps -p <PID>          -Display this specific process PID
ps -aux | grep "command"  - your command process

Process Priorities:
Nice values: range -20 (highest priority) to 19 (lowest).
nice -n 10 command    - run command with nice command
renice -5 -p 1234     - manage niceness of existing process with PID
nice -n 15 big_script.sh & - run scripts with nice value in background

20. user management: 
super user - root (UID -0 and GID -0) root
system user - (UID 1-999 and GID 1-499) created for services (e.g., nginx, mysql).
normal user - profiles (UID 1000-60000 and GID 1000-60000)
every user has UID and GID.

superuser access:

add username to visudo file to give user an administrative access.
pawan ALL=(ALL) NOPASSWD:ALL
add user to the wheel group to give user an admin access.

you can add this in /etc/sudoers

21. UID GID:
Id pawan  :will give you GID and UID of user pawan

User management:
useradd pawan : new user pawan created
su pawan :switch user to pawan
passwd :set passwd for current user
sudo usermod -aG group1 ${USER} : adding USER to group1 to inherit its permissions.

Creating group and adding user to a group:
groupadd group1            :group named group1 has been created.
usermod -aG group1 pawan   :user pawan has been added in group1.

userdel -r pawan
command to delete user 'pqz' ; -r will remove ~ directory and bash profile files.

25. permission management for folder and file:
read, write and execute
 r=4     w=2     x=1
rwx=7

to check file/folder/directory permission: ls -la
to check storage of file: du -h file.txt

permission syntax: owner group other advanced CL
 rwx-rx-rx.   :owner rwx, group rx, other rx


Default Permission:
default permission if root user created directory: 755
default permission if root user created file: 644
default permission if normal user created directory: 775
default permission if normal user created file: 664

26. Permission management lab:
chmod is change mode. it is used to give permission from root to
other/group.
chmod u+x /tmp  :added executed permission to user/owner
chmod o-x /tmp  :removed execute permission for others to file tmp
chmod g+w /tmp  :write permission given to group to file tmp

chgrp to change group owner of file/directory.
chgrp staff example.txt                            #changes group owner of the file example.txt

chown to change owner of file/directory.
chown john:users example.txt                       #changes both, user owner and the group owner of the example.txt


27. permission management numeric method:
R=4 W=2 X=1
To give permission:
chmod 777 tmp  -all permission to (owner,group,other) to tmp
chmod 700 tmp  -owner all and group/other no permission

28. umask for default permission:
root user for default umask = 022
root user for default umask = 002

default value for directorary = 777 - umask value
default value for file = 666 - umask value

umask 666  :umask value change to 666 (temporary)
vim .bashrc and write umask 666 for permanent

29. ACL: access control list
setfacl -m u:pawan:rwx    -give rwx permission to user pawan
getfacl pawan             -list all permissions of pawan

31. Partition management:
Partitions are sections of a hard drive or storage device that are treated as separate units
go to #50.

A partition is a logically divided section of a physical disk.
Each partition can hold a filesystem (ext4, xfs, etc.) or swap space

Partition Table Types:
MBR (Master Boot Record):                                 | GPT (GUID Partition Table)
-old                                                      | -modern standard
-supports up to 4 primary partitions                      | - supports 128 partitions
-max disk size ~2TB                                       | - works with large disks (>2TB)

lsblk - list all disks
fdisk -l  -detailed info about disks
blkid        -Partitions detailed UUId

types of hardisk: SATA and PATA
SATA:
PATA:

32. if-then-else-fi loop:

 1.if [ -e "$filename" ]; then
   # if file or directory exits

 2. if [ -f "$filename" ]; then
   # if file is file (not dire. or special file)

 3. if [ -d "$directory" ]; then
   # if directory is a directory

 4. if [ -s "$file" ]; then
   # if filesize is greater than 0

# if block is non-zero then execute code
if [ -n $filename ]; then
	echo ""
elif []; then
	echo ""
else
	echo ""
fi

 5. if [ $num1 -eq $num2 ];   #if number1 is equal to number2

 6. if [ $num1 -ne $num2 ];   #if num1 is not equal to num2

 7. if [ num1 -lt num2 ];    #if num1 is less than num2

 8. if [ num1 -le num2 ];    #if num1 is less than or equal to num2

 9. if [ num1 -gt num2 ];    #if num1 is greater than num2

 10.if [ num1 -ge num2 ];    #if num1 is greater than or equal to num2

#written in hackerrank
read X
read Y
if [[ $X -gt $Y ]]; then
	echo "X is greater than Y"
elif [[ $X -lt $Y ]]; then
	echo "X is less than Y"
elif [[ $X -eq $Y ]]; then
	echo "X is equal to Y"
fi

#if triangle is isocelese or equilateral or scalene
if [[ $X -eq $Y && $Y -eq $Z ]]; then
    echo "EQUILATERAL"
elif [[ $X -eq $Y || $Y -eq $Z || $X -eq $Z ]]; then
    echo "ISOSCELES"
else
    echo "SCALENE"
fi

if [ -n $filename ]; then       :if string is non-zero then execute..
if [ -z "$string" ];            :if string is zero/empty.
if [ $? -eq 0 ];                :if above command is successful
if [ "$(id -u)" -eq 0 ];        :if user has superuser privileges
if pgrep "$process_name" > /dev/null;    :if process is running
if [ -w "$file" ];      :if file is writable/readble(-r)/executable(-x)

33. Declaring Variables:
   name="Pawan"        -Pawan is stored in "$name" (no space)
   var=$(ls -la)         #o/p value is stored in $var.

34. Taking input from user:
    echo "Write your name here:"
    read user_name      
    #name is stored in "$user_name"

add=$((X + Y))    ; echo "$add"
diff=$((X - Y))   ; echo "$diff"
prod=$((X * Y))   ; echo "$prod"
div=$((X / Y))    ; echo "$div"


35. for-do-done loop:
1.for i in {1..5};    / 1,2,3,4,5
  do
    echo "number is $i"
  done
2. for i in {1..5}; do
    for j in {1..5}; do
        result=$((i * j))
        echo "$result"
   done

36. while-do-done loop
1. count = 1
   while [$count -le 5];
   do
     echo "$count"
     ((count++))
   done
2. while true;
   do
     echo "Please update the package"
     sleep 60
   done


37. Case esac Expression:

echo "please choose A or B"
read choice

case $choice in
    A|a) echo "You chose option A" ;;
    B|b) echo "You chose option B" ;;
      *) echo "Invalid Input" ;;
esac


38. Defining Function:

Function_name() {
    echo "Add your command here"
    var=$(ls -la)
}

#calling your function
Function_name

39. Accessing inside content:
packages=("curl" "tree" "package1" "package2" "package3")

echo "${packages[@]}"                  -it will access every content inside packages and will echo it.
for i in "${packages[@]}"; do
done

Networking commands:
1. PING will send ICMP packets to the server to test the reachability of a host
ping google.com  : it will send ICMP packets to the domain/host google.com
                   you can define packet size or how many packets with various flags/options.
                   It helps with checking network connection with packet loss stats.

2. netstat will show you network statistics (port listening, active network connections, routing tables)
   netstat -alp       : all listening ports
   netstat -tulnp     : tcp udp listening numeric port


3. nslookup  will show you ip addresses of domain
nslookup google.com

4. traceroute will show you no. of hops packets takes before reaching to the target server.

5. ifconfig:
will show you info on NIC n/w interface cards.
mostly eth0 and one logical NIC lo (local)

> "ens5: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 9001"
it is showing you interface is up and running, broadcast is working and maximum transmission unit size is 9001 bytes.

> "inet 100.117.95.90  netmask 255.255.255.192  broadcast 100.117.95.127"
inet → IPv4 address = 100.117.95.90
netmask = 255.255.255.192 → means subnet /26 (64 IPs total, 62 usable).
broadcast = 100.117.95.127 → broadcast address of the subnet. (special address used to send packets to all hosts)
The 
rest of the things are IPv6 and transmitted and received packets.

1st IP → Network address (not usable). used to identify network itself.
Last IP → Broadcast address (not usable).

# AWS VPC Networking (special rules):
AWS reserves 5 IP addresses in every subnet, regardless of size:
> Network address → 1st IP (e.g. 100.117.95.64)
  Identifies the subnet itself.
> VPC router/gateway → 2nd IP (e.g. 100.117.95.65)
  Always used as the default gateway for instances.
> Reserved for AWS mapping → 3rd IP (e.g. 100.117.95.66)
  AWS keeps it for internal purposes.
> Reserved for AWS DNS → 4th IP (e.g. 100.117.95.67)
  Used for Amazon DNS in the subnet.
> Broadcast address → Last IP (e.g. 100.117.95.127)
  Even though AWS does not support broadcast, this IP is still reserved.

https://chatgpt.com/s/t_68de444b8f888191a2271d2d46e72b52

6. ss  (sockets by state) (alt to netstat) Information about TCP, UDP, and Unix domain sockets. 
       It provides real-time data on network connections, listening ports, and other socket-related information
   ss -alp : all listening ports
   ss -tulpn : tcp udp listening number ports
listening ports command use to check if any unwanted service is running, or webapps are running or port conflicts (many apps on single ports).


7. curl used to make HTTP requests using command line, supports http/s , ftp and many more.
used in api, connectivity, testing, downloading. 
gives you raw api response.

curl -L: follow redirects 301/302
curl -I: show headers only (Key–value pairs sent before the body of an HTTP request or response)

8. wget is  utility for retrieving files from the internet using various protocols like HTTP, HTTPS, FTP.
mainly used for downloading stuff.

10. lsb_release -a :will show you the version of Linux. (cat /etc/os-release)

11. lsof : will list open files
    lsof -i :8080        :will show you the port if listening and PID etc
    lsof -p 8558         : will show detailes of PID 8558
    lsof -u eugapaw        :list of open file by user eugapaw
    lsof -c <command>    :list open file by command

12. nmap localhost: use it to scan for open ports on a machine.
CLI tool for port discovery, service/version detection, OS fingerprinting, and basic vulnerability/scripted checks. 
Used for inventory, troubleshooting, and security auditing

14. SAR (System Activity Reporter): a command-line tool for collecting, reporting, and analysing system activity in a 10-minute time interval.
CPU     %user     %nice   %system   %iowait    %steal     %idle
ALL

15. route : this command shows, add, deletes the IP routing table.

16. firewalld: is a dynamic firewall manager that provides a simpler interface for managing firewall rules.
Both iptables and firewalld aim to control and filter network traffic.

17. tcpdump is a packet analyzer that allows you to capture and analyze network traffic.

18. Check system logs for network-related issues. Common log locations include /var/log/syslog, /var/log/messages, and /var/log/secure.

19. The /etc/fstab file contains information about disk drives and partitions

yum install -y package*  : install package and related files
yum list installed       :list of packages installed in system
yum remove package       : remove package

rpm, yum, and dnf:
1. RPM (Red Hat Package Manager): It does not resolve dependencies automatically. You need to manually install all required dependencies.
   RHEL, CentOS, and Fedora.
2. YUM (Yellowdog Updater, Modified): works on top of rpm to automatically resolves and installs dependencies for the package being installed.
   RHEL, CentOS, and Fedora.
3. DNF (Dandified YUM): dnf is the next-generation version of yum. same as yum but improved performance, better dependency resolution.
   dnf uses the libsolv library for faster and more accurate dependency resolution.
4. apt (advanced package tool): Used in Debian-based distributions like Ubuntu.
5. Zypper: Used in openSUSE.
   zypper install <package-name> 

40. systemctl: Two commonly used service management systems in Linux are systemd and traditional init scripts.
                                                                         (load ,   Active,   SUBstate)
systemctl list-units                    = will make list of all services (loaded, active, active)
systemctl list-units --state=active     = will make a list of services where state is active.
systemctl list-units --state=inactive   = will make a list of services where state is inactive
systemctl status sshd                   = will show you status of service named sshd (includes load, activer, PID, memory, cpu, path)
systemctl stop sshd                     = will stop the service sshd (inactive) (if you reboot, it will get started)
systemctl stop sshd ; systemctl disable sshd = will stop and disabled service permanently (if you reboot it will still be disable)
systemctl start sshd                    = will start the sshd service
systemctl start sshd ; systemctl enable sshd = will start and enable it permanently (if you reboot it will still be enable)
systemctl restart sshd                  = will stop and start the service sshd
systemctl reload sshd                   = it will reload the file, not start/stop/restart hence PID will remain same. 
                                          (restart or stop/start will give you new PID)
systemctl mask sshd                    = it will mask the service sshd, means sshd will not get started at any circumstance (not even when start/stop/restart/reboot)
systemctl unmask sshd                   = it will unmask the previously mask service.
systemctl poweroff                      = shutdown right now
journalctl -u servicename               = view service logs

41. kill and kill -9
syntax:
kill [signal] PID
kill PID: (default -15) Allows the process to handle the signal and perform cleanup operations(gracefully) before termination.
kill -9 PID: Forcibly terminates the process without allowing it to perform any cleanup.
killall:  this command kills processes by name rather than by process ID

42. rsync (remote synchronization) (ssh protocol)

rsync -avz /path/to/local/directory user@IPaddress:/path/to/destination/directory

This command would transfer files from the local source directory to a remote destination directory. (archive, verbose, zip)

by default, rsync never remove/delete files in destination, you have to add --delete for complete mirror syncing.
--delete for mirror mode
(if vpc peering is done, then privateIP if not then publicIP)
It also syncs content of files within directory, if any difference found in source/directory/*.log and destination/directory/*log then it will sync automatically.

43. Understanding Load Average:
    Load averages indicates the average number of processes competing for the CPU over different time intervals (1, 5, 15 min)

1-minute load average: Represents the average number of processes in the runnable state over the last 1 minute.
5-minute load average: Represents the average number of processes in the runnable state over the last 5 minutes.
15-minute load average: Represents the average number of processes in the runnable state over the last 15 minutes.

A load average of 1.00 on a single-core system means that the system is fully utilized. 
On a multi-core system, a load average of 4.00 on a 4-core machine, for example, indicates full utilization.

A load average below the number of available CPU cores typically indicates that the system is handling the load well.
A load average higher than the number of CPU cores suggests a potential performance bottleneck

uptime     :this command provides a quick overview of the system's load averages (1 min, 5 mins, 15 mins)
w          :w command provides information about the current users and their activities, including load averages.

44. top          : will show you the cpu usage along with process info.
    htop         : is human friendly top command package.
    free         : will show you memory total, used, free. (free -m for MiB , -g Gib)
    df -h        : will show you disk space.

top command:
%Cpu(s): 71.2 us, 4.3 sy, 0.0 ni, 23.9 id, 0.4 wa, 0.0 hi, 0.2 si, 0.0 st
user system nice idle wait hardware-interrupt software-interrupt stolen

%steal in cpu : it shows you cpu used by another machine in hypervisor and hence stealed from you by CSP.
hypervisor is added to create many servers from one large single server.

press shift + i = I to turn off the irix mode, for %cpu to display w.r.t 100%
press i to ignore zombie process, only show active process
press u and type username and enter to find processes with that user
press V (shift + v), will show you processes in tree format like parent and child processes
W → Save current config to ~/.toprc


45. Log Files and Their Locations:
Syslog (System Logs): standard logging protocol: /var/log/syslog
Kernel logs: messages related to Linux kernel:   /var/log/kern.log
Authentication logs:  info about user logins:    /var/log/auth.log
Application Logs: applications logs in dedicated files: /var/log/nginx/access.log
system boot logs: info about the system boot process:  /var/log/boot.log

46. Installing application from source code:
install its dependencies as per documentation.

Installing application from source code:
Download the source code, usually a .tar.gz or .tar.bz2
wget <URL>

1. Extract the archive:
- tar -xzf <file-name>.tar.gz

2. go to specified directory:
- cd <extracted-directory>

3. Check for Installation Instructions: readme/install files

4. "configure" file comes with downloaded source code. Running ./configure checks system if it has required tools and libs needed to build software.
It sets up a "Makefile" (used by make command) with the right paths & config. for your system.
- ./configure

5. make compiles the source code into executable files. make command takes the instructions from the Makefile and starts building (compiling) the software.
converts human-readable source code (like .c or .cpp files) into machine-readable code (binaries).
- make

6. Installs the compiled software system-wide.
- sudo make install

7. package name --version 

47. Patching a source file
cd /path/to/source_code
patch -p1 < /path/to/patchfile.diff

48. Configuring mail on Linux server:
1. Install Required Packages: 
Ensure the mailx package is installed on your linux.
- sudo yum install mailx

2. Configure Postfix to Use SMTP Relay: Edit the Postfix configuration file /etc/postfix/main.cf.

3. sudo nano /etc/postfix/main.cf

4.Add or modify the following lines:
   relayhost = [smtp.example.com]:587
   Replace [smtp.example.com]:587 with your SMTP server's hostname and port number. 
   For Gmail, use [smtp.gmail.com]:587.

5. Create Authentication File: Create a file to store your SMTP authentication credentials.

6.sudo nano /etc/postfix/sasl_passwd
  Add your SMTP server's details along with your username and password.

7. [smtp.example.com]:587 your_username@gmail.com:your_password
   Secure Authentication File: Restrict access to the authentication file.

8. sudo chmod 600 /etc/postfix/sasl_passwd
   Update Postfix Configuration: Update the Postfix lookup table.

9. sudo postmap /etc/postfix/sasl_passwd
   Reload Postfix Configuration: Apply the changes to Postfix.

10. sudo systemctl reload postfix
    Test Email Sending: Send a test email to verify the setup.

11. echo "Test email body" | mail -s "Test Email" recipient@example.com
    Replace recipient@example.com with your email address.

Following these steps should enable your CentOS machine to send emails using your Gmail account or any other SMTP server you've configured.

49. SSH (Secure Shell:22):

ssh -i ~/.ssh/id_rsa -p 2222 -v ec2-user@192.168.1.100 "uptime"
-i : for attaching keys
-p : ssh port of the server
-v : verbose for debugging
you can also add command under "command" and it will get executed.

local port forwarding:
ssh -L 8080:localhost:27017 user@192.168.1.100
if mongodb is hosted on remote server's 27017 port, by running this command you can access it locally from localhost:8080

remote port forwarding: (not making sense)
ssh -R 9090:localhost:22 user@192.168.1.100
If your local machine runs an SSH server on port 22, by running this command, you can SSH into it from the remote server.
ssh -p 9090 user@localhost

SOCKS Proxy: SOCKS proxy in SSH is a way to tunnel your local traffic through an SSH connection, turning your SSH client into a proxy server.

ssh -D 9090 -N -q user@remote-server.com

Your connection appears as if it's coming from the remote server ; bypasses restricted sites on network; acts as VPN/proxy.
-D 9090 → Creates a SOCKS proxy on local port 9090.
-N → No remote command execution, just keep the tunnel open.
-q → Quiet mode (suppresses messages).

Set this to cmd where you want to tunnel traffic through remote server as proxy.
set HTTPS_PROXY=socks5://localhost:8081

SSH Config file: 
1. open ~/.ssh/config and add details:

Host myserver
    HostName 192.168.1.100
    User username
    Port 2222
    IdentityFile ~/.ssh/id_rsa

Now connect machine with only: ssh myserver

ssh-keygen: command will generate private and public key.
Public key is used to encrypt data that only the corresponding private key can decrypt.
Private key is used to decrypt data that was encrypted with the corresponding public key.

authorized_keys: Stores public keys of the devices that are allowed to access your account.
known_hosts: Keeps fingerprints of remote servers you’ve connected to.
known_hosts.old: A backup of the known_hosts file.

keyless connection between 2 servers:
1: Generate an SSH Key Pair
2. ~/.ssh/id_rsa
3. Copy the SSH Public Key to the Remote Server(~/.ssh/authorized_keys): ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote_server_ip
4. same steps for other server if you want to create connection both ways.
5. generate public key and store it in ~/.ssh/authorized_keys of remote server.

ssh-keygen -t rsa -b 2048 -m PEM -f ~/my-aws-key.pem
it will generate pvt (pem) keys and pub keys in home directory.
put pub keys in ~/.ssh/authorized_keys to allow logins from this pub key.

disabling root login on Linux:
1. Open the SSH configuration file:
2. Find the line PermitRootLogin says: PermitRootLogin no
3. systemctl restart sshd

50. [Mounting a disk: full process]:
1. lsblk: list all block devices attached to server with dev/sdX
2. partition disk: sudo fdisk /dev/sdb         	Type n to create a new partition.
						Choose p for primary partition.
						Enter 1 for the first partition number.
						Choose the default first sector (press Enter).
						Type +500G to create a partition of 500GB.
						Type w to write the changes to the disk.

3. format the partitions: sudo mkfs.ext4 /dev/sdb1
4. Create Mount Points /folders: mkdir mfgpro
5. mount the partitions: sudo mount /dev/sdb1 /mfgpro
6. Make the Mounts Persistent (partition auto add after boot), you need to add them in /etc/fstab:
   6A: get uuid of partitions: blkid /dev/sdb1
   6B: add it in fstab: <UUID1>  /mfgpro  ext4  defaults  0  2
7. Verify the Mounts: mount -a ; df -h

Logical Volume Management(LVM):
More flexible than fixed partitions.
Useful for resizing volumes dynamically in production.

1. Create PV (Physical Volume):
pvcreate /dev/sdb1

2. Create VG (Volume Group):
vgcreate data-vg /dev/sdb1

3. Create LV (Logical Volume):
lvcreate -L 10G -n data-lv data-vg

4. Format and Mount LV:
mkfs.ext4 /dev/data-vg/data-lv
mount /dev/data-vg/data-lv /mnt/data

5. Resize when needed:
lvextend -L +5G /dev/data-vg/data-lv
resize2fs /dev/data-vg/data-lv


51. Hidden Files/Folders in home directory:

.bash_history - stores commands typed in bash shell.
.bash_logout - executes this script when you logout from bash session.
.bash_profile - executes this script once when you login to server. (manual login = interactive shell)
.bashrc - executes this script for every non-interactive shell. (script login using !#/bin/bash = non-interactive shell)
.lesshst - history for less command, which files you have opened using the less command (non-human-readable file)
.viminfo - history for vim editor, same as .lesshst and non-human-readable
.ssh - stores SSH configurations and keys

--------------------------------------------------------------------- Additional notes -------------------------------------------------------------------

RSH stands for Remote Shell. RSH is not commonly used today due to security concerns, as it transmits data, 
including passwords, in plaintext.
TCP port 514.

XDMCP stands for X Display Manager Control Protocol. It is a network protocol used for remote graphical login to a computer running the X Window System

VNC stands for Virtual Network Computing. It's a graphical desktop-sharing system that allows you to remotely control another computer regardless OS.

Mosh, short for "mobile shell," is a remote terminal application that enhances the capabilities of traditional SSH (Secure Shell) for remote access to Unix-like systems.

$1: This is a positional parameter representing the first command-line argument passed to the script or function. 
If you execute a script with an argument like ./script.sh Alice, where script.sh is the name of the script, 
then $1 will be replaced by "Alice". If no arguments are provided, $1 will be empty.

"wine" is a compatibility layer capable of running Windows applications on Unix-like operating systems such as Linux.

"arp" command is used to view and manipulate the ARP (Address Resolution Protocol) cache, which maps IP addresses to MAC (Media Access Control) addresses on a local network.

TTL stands for "Time to Live" and represents the maximum number of hops (routers) that the ICMP echo request packet is allowed to traverse before being discarded.

[March 2024]

config files are usually stored in /etc/../*.conf

> dev/null      output will be suppressed and discarded.
2>&1

crontab -l : will list scheduled cron jobs
crontab -e : open vi editor for scheduled cron jobs


IP Address Classes:
Class A: 10.0.0.0 - 10.255.255.255            10.0.0.0/8         255.0.0.0      ~ 16 million IPs available                             BIG
Class B: 172.16.0.0 - 172.31.255.255          172.16.0.0/12      255.240.0.0    ~ 1 million IPs available (default for AWS VPC)        Medium
Class C: 192.168.0.0 - 192.168.255.255        192.168.0.0/16     255.255.0.0    ~ 65K IPs available                                    Small

Today, we don’t use classes much; instead, we use CIDR (Classless Inter-Domain Routing) notation (such as/8, /12, /16).

|| exit 1  : logical OR, if command fails, then exit 1.

lscpu
list no. of cpu cores

create a user and group and add user to group:
useradd mfg
groupadd qad
usermod -aG qad mfg

give sudo rights to user:
visudo

lsblk
list no. of disks attached.
you need to create further partition in these disks.

netstat -tuln
ss -tuln
displays tcp udp listening ports, show numerical address

Creating a repository files:
/etc/yum.repos.d/mongodb-org.repo

which git
This command will display the path to the Git binary (/usr/bin/git)

ipcs -l
check semaphore limit on Linux

/etc/logrotate.conf
log rotation configuration file to remove old logs on scheduled basis.

[April 2024]:

To connect to any database you need,
dbcommand ; ip address      ; port        ; username and password ; DB name
binary      of machine        where data     of that database       (optional)
            where db hosted   hosted                                 for r/w

npm - node package manager
nvm - node version manager 

there's no tool available to rename existing DB in system for mongodb.

tail -f <logfile> for live logs as they come.

List all installed packages: rpm -qa

scp -r username@remote_server_ip:/path/to/save/dump /path/to/local/directory
remote to local FTP
scp [options] [source] [destination]

userdel -r pqz
command to delete user 'pqz' ; -r will remove ~ directory and bash profile files.

mpstat
Multiprocessor Statistics command ; it will show you cpu %idle %iowait %usr %nice

kill process forcefully:
kill -9 PID
kill process gracefully:
kill PID

du -sh <filename>
disk usage summary humanreadable of <filename>

truncate -s 0 boot.log
truncate is used to shrink/extend the file of size.
here it will shrink the size of boot.log file to 0 byte.

truncate -s 5M /var/log/boot.log
here it will extend the size of boot.log file to 5MB.

crontab -l command to list crontab scheduled jobs
crontab -e command to edit crontab scheduled jobs.

to check if command exist or not, check in /usr/bin/ or /usr/local/bin

very secure ftp daemon
sudo yum install vsftpd
package you need to have while dealing with ftp.

top command:
%Cpu(s): 71.2 us, 4.3 sy, 0.0 ni, 23.9 id, 0.4 wa, 0.0 hi, 0.2 si, 0.0 st
user system nice ideal wait hardware-interrupt software-interrupt stolen

echo "This is the body of the email" | mail -s "Subject of the email" recipient@example.com

routing:
path based routing: example.com/products ; example.com/about
host based routing: product.example.com ; about.example.com 

change hostname of machine:
sudo hostnamectl set-hostname com.qad.qip

configuring email server on Linux:
install postfix: apt install postfix
/etc/postfix/main.cf -  relayhost = [smtp.office365.com]:587
			smtp_tls_security_level = encrypt
			smtp_sasl_auth_enable = yes
			smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd
			smtp_sasl_security_options = noanonymous
add username and passwd in /etc/postfix/sasl_passwd:
[smtp.office365.com]:587    <username>:<password>
give permission: chmod 600 /etc/postfix/sasl_passwd
update configuration: postmap /etc/postfix/sasl_passwd
restart to apply changes: systemctl restart postfix

Mail send command: echo "This is a test email" | mail -s "Test Subject" recipient@example.com

Installing mailx
yum -y update
yum install -y mailx
We can now start sending e-mails using

create a symbolic link

ln -s /bin/mailx /bin/email
###Set an External SMTP Server to Relay E-Mails

vi /etc/mail.rc
edit

set smtp=smtps://smtp.gmail.com:465
set smtp-auth=login
set smtp-auth-user=USERNAME@YOURDOMAIN.COM
set smtp-auth-password=YOURPASSWORD
set ssl-verify=ignore
set nss-config-dir=/etc/pki/nssdb/
example usage :

echo "Your message" | mail -v -s "Message Subject" email@address

find /path/to/directory -type f -exec du -h {} + | sort -rh | head -n 10

ncmpcpp (NCurses Music Player Client (Plus Plus)) is a feature-rich, ncurses-based client for the Music Player Daemon (MPD).

Monitoring tools: top, htop, iotop, atop, glances

Class A: 10.0.0.0 to 10.255.255.255
Class B: 172.16.0.0 to 172.31.255.255
Class C: 192.168.0.0 to 192.168.255.255
local: 127.0.0.1
APIPA: 169.254.0.0 to 169.254.255.255
Broadcast Addresses: 255.255.255.255

ARP requests use broadcasts to discover the MAC address of a device associated with a given IP address.

Firmware enables the hardware to communicate effectively with the higher-level software (like operating systems and applications)

[June 2024]

which <command>
command will show you command path where it is stored. /usr/bin/

vmstat command will show you virtual machine statistics:

%steal in cpu : it shows you cpu used by another machine in hypervisor and hence stealed from you by csp.
hypervisor is added to create many servers from one large single server.

operating system will move inactive pages (blocks of data) from the physical RAM to the swap space. 
This process is known as paging or swapping out.

[Mounting a disk: full process]:
1. lsblk: list all block devices attached to server with dev/sdX
2. partition disk: sudo fdisk /dev/sdb         	Type n to create a new partition.
						Choose p for primary partition.
						Enter 1 for the first partition number.
						Choose the default first sector (press Enter).
						Type +500G to create a partition of 500GB.
						Type w to write the changes to the disk.

3. format the partitions: sudo mkfs.ext4 /dev/sdb1
4. Create Mount Points /folders: mkdir mfgpro
5. mount the partitions: sudo mount /dev/sdb1 /mfgpro
6. Make the Mounts Persistent (partition auto add after boot), you need to add them in /etc/fstab:
   6A: get uuid of partitions: blkid /dev/sdb1
   6B: add it in fstab: <UUID1>  /mfgpro  ext4  defaults  0  2
7. Verify the Mounts: mount -a ; df -h

https://chatgpt.com/c/11516aae-e840-4494-b713-b3b9b12f5a72

npm install command is used to install all the dependencies listed in your project's package.json file.
npm fetches these packages from the npm registry.
dependencies are installed into a directory called node_modules.

Using a process manager like PM2 ensures that your application runs in the background and restarts on failure.

nginx notes:
sites-available: Contains configuration files for all available sites.
sites-enabled: Contains symbolic links to the configuration files of enabled sites.

TLS is the successor to SSL, and while the term SSL is still commonly used, most modern secure communications use TLS.

Network File Storage (NFS) is a type of storage system that allows multiple users and systems to share files over a network.


main_function () {
-----------script---------
}

main_function 2>&1 >> $LOGDIR/mongodbbackuptoblob_$TIME.log
it will store standard error (2) and standard output (1) to $LOGDIR/mongodbbackuptoblob_$TIME.log

nload: Another real-time network usage monitor.

lshw: Lists detailed information about the hardware configuration.

nmon: Performance monitoring tool designed for AIX and Linux operating systems.

sar: system activity reporter shows you diff resources (cpu, mem, io) values from 00:00 start of the day within 10 min time interval.

lastlog command reports the most recent login of all users or of a given user.

auditd: Linux Auditing System can track activities performed by users.


Create rules to monitor specific activities. For example, to monitor changes in /etc/passwd:
sudo auditctl -w /etc/passwd -p wa -k passwd_changes

Use ausearch and aureport to view and analyze audit logs:
sudo ausearch -k passwd_changes
sudo aureport -f -i

psacct package can be used to monitor user commands

sa: Summarize accounting information.
lastcomm: Show the last commands executed by users.
accton: Turn on accounting.

[July]

You can check your DNS settings in the /etc/resolv.conf file.

yum repositories notes:

/etc/yum.repos.d/*.repo
base url where yum repos are fetched known as mirrorlist.

tracert (trace route) is used to track the path that a packet takes from your computer to a specified destination.

if loop options:

File Existence:
-e file : Checks if the file exists (regardless of type).
-f file : Checks if the argument is a regular file.
-d file : Checks if the argument is a directory.
-h file or -L file : Checks if the file is a symbolic link.
-b file : Checks if the file is a block device.
-c file : Checks if the file is a character device.
-p file : Checks if the file is a named pipe.
-S file : Checks if the file is a socket.

File Permissions
-r file : Checks if the file is readable.
-w file : Checks if the file is writable.
-x file : Checks if the file is executable.

File Characteristics:
-s file : Checks if the file is not empty.
-t fd : Checks if the file descriptor fd is open and associated with a terminal.
-O file : Checks if the file is owned by the effective user ID.
-G file : Checks if the file is owned by the effective group ID.
-N file : Checks if the file was modified since it was last read.

File Comparison:
file1 -nt file2 : Checks if file1 is newer than file2.
file1 -ot file2 : Checks if file1 is older than file2.
file1 -ef file2 : Checks if file1 and file2 refer to the same inode(metadata).

String Tests:
Equality:
str1 == str2 : Checks if two strings are equal.
str1 != str2 : Checks if two strings are not equal.

Empty/Non-Empty Strings:
-z string : Checks if the string is empty.
-n string : Checks if the string is not empty.

Numeric Comparisons:
Equality and Inequality:
num1 -eq num2 : Checks if num1 is equal to num2.
num1 -ne num2 : Checks if num1 is not equal to num2.

Relational Comparisons:
num1 -gt num2 : Checks if num1 is greater than num2.
num1 -lt num2 : Checks if num1 is less than num2.
num1 -ge num2 : Checks if num1 is greater than or equal to num2.
num1 -le num2 : Checks if num1 is less than or equal to num2.

Logical Operators:

AND
[ condition1 ] && [ condition2 ]
[[ condition1 && condition2 ]]

OR
[ condition1 ] || [ condition2 ]
[[ condition1 || condition2 ]]

NOT
! condition
Compound Conditions
Grouping Conditions
[[ condition1 && ( condition2 || condition3 ) ]]
(( arithmetic_expression ))

Using if with && and || directly:
if [ condition ] && [ another_condition ]; then
Exit Status Checks
Command Success

if command; then : Executes the if block if command returns an exit status of 0 (success).
Command Failure

if ! command; then : Executes the if block if command returns a non-zero exit status (failure).
Special Considerations
Arithmetic Evaluations

[ $(( expression )) -eq 0 ] : Evaluates arithmetic conditions.
(( expression )) : A more compact way to evaluate arithmetic conditions.
Advanced Conditional Expressions

[[ ]] : Used for more powerful pattern matching and string comparisons.
[ ] : The traditional test command (less powerful than [[ ]]).

if [ $? -eq 0 ]; then
if above command is successful, then exit code would be 0.

./your_script.sh > script_output.log 2> script_error.log
redirecting standard output logs using >
redirecting error logs using 2>

Each core is capable of executing its own instructions and performing tasks independently from other cores.
Each core can also have multiple threads, which are the smallest sequence of programmed instructions that can be managed independently by a scheduler.

available memory includes both the free memory and the reclaimable memory from the cache and buffers.

Blocks have a size of 512 bytes.

OpenSSL can create SSL/TLS certificates, which are used to secure communication between servers and clients (like your browser and a website).

change branch name in git:
git branch -m old-branch-name new-branch-name

time command in Linux is used to measure and display the time taken to execute a command or a program.

Single Sign-On (SSO) is an authentication process that allows a user to access multiple applications or systems with a single set of login credentials.

cmd in dockerfile:
CMD ["binary executable", "argument1", "argument2"]

Artifacts are the output files produced by the build process.
bash script is a specific type of shell script that is written for the Bash (Bourne Again SHell) interpreter.
Build: The process of converting source code into a runnable application. It may include compiling code, packaging it, and generating executables.
Test: The stage where automated tests are run to validate the code’s functionality. This can include unit tests, integration tests, and end-to-end tests.
Deployment: The process of moving code from a development or testing environment into a production environment where it is available to end-users.
Artifact: A file or set of files produced during the build process, such as compiled code, documentation, or configuration files.
ntp: network time protocol: package is essential for synchronizing the system clock of your server or computer with a reliable external time source
hosts file is a plain text file used by operating systems to map hostnames to IP addresses locally.

Swappiness Value Range: 0 to 100 ; default:60 ; 0 low use of swap space ; 100 high use of swap space.
core dump is a file that captures the memory contents of a process at a specific point in time, typically when the process has crashed or terminated unexpectedly.
Disk space refers to the storage capacity available on a server's hard drive (HDD) or solid-state drive (SSD)
CPU responsible for executing instructions from programs by performing arithmetic and logical operations.
RAM is a type of volatile memory used to store data that the CPU needs quick access to,  faster than disk, loses data when powered off.

Throttling Resource Usage:
ionice -c2 -n7 <command>  # Set to best-effort with lowest priority
cpulimit -l 30 -- <command>
renice -n 19 -p <PID>  # Change the priority of a running process
nice -n 19 <command>  # Lower priority (values range from -20 to 19)
trickle -d 100 -u 50 <command>  # Limit download to 100KB/s and upload to 50KB/s
ulimit -v <memory_in_kb>  # Limit virtual memory usage

you can also use systemd to configure resource limits for services running on your system.
/etc/systemd/system/my_service.service

Git rollback to prev version:
Identify the Commit Hash of the Previous Version: git log
Check Out the Previous Version: git checkout <commit-hash>
Reset the Current Branch to the Previous Version: git reset --hard <commit-hash>
Push the Previous Version to the Repository :git push origin <branch-name> --force

batch file(.bat or .cmd) is equivalent to shell script(.sh) file for windows.

/var/spool directory in Linux is used to store files that are waiting to be processed by some system service or daemon.

[September 2024]




-----------------------------------------------------------------------------QAD---------------------------------------------------------------------
When a Linux process is terminated by a signal, it returns an exit code that follows this formula:

Exit Code = 128 + <signal number>

So:
Exit Code 137 = 128 + 9
128 is the base used to indicate "killed by a signal"
9 is the signal number for SIGKILL

--how to take a heap dump


--how to base64 encode folders/directories to share 
https://chatgpt.com/share/68a33e3c-c964-8012-963b-f3f2e2917a7f

1. zip/tar/7z compress the folder to make it file

2. encode it with base64

3. decode it with base64

4. extract it in its original form
